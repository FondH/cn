## 21-NKU计算机网络
### homework 1 ：实现多人聊天室（单服务器 多房间 多人）

> 建议先搞懂socket编程的原理：bind、send、sendto(虽然本次实验不会用到)每个参数的意义。

### homework 2 ：WireShark 抓包

> 时代变了，课本的内容完全不足以应对现实。

### homework 3 ：UDP 可靠传输

> 分为三部分内容，均复现课程学到的相关状态机即可，传输机制从`停等`到`GBN`到`SR`；
>
> GBN代码在分支`StableUdp-Part2`中，SR在`StableUdp-Part3`中，具体参数的修改，需要调整.h文件中对应的地方。

- 第一次停等机制，发送、接受均单线程即可，而是否为了保证传输数据通道的可靠，而加入挥手、握手机制值得深思(毕竟加入是为了保证通道的可靠，而不是仅仅是一个流程）

- GBN和SR均含有窗口思想，相比他们的**相同点**：

  - 他们发送端均需要维护一个长度为N的窗口大小，在窗口大小内的数据才在发送线程里发送；同时需要维护一个缓冲区将这些发送过，但暂时还未被接收端确认的数据包缓存起来，以便后续重发机制进行重发；

  而**不同点**：

  - 首先是接收端，GBN的接收端采取停等机制类似操作即可，只是每一次它回复的ack仅仅由刚刚接受到的数据包的seq决定（为每一个数据包编码一个独特的序列号seq是窗口机制的前提保证）；因此，GBN的接收端似乎并不需要考虑‘窗口’的概念。而SR的接受端

    需要有窗口的概念，将收到的数据包（可能不是的顺序的）按序能存入本地（这里实现方式很多了），同时回复刚刚顺利存下的数据包序列号对应的ack包

  - 其次是发送端，GBN累计确认，意思收到n的ack包，实则将现在窗口内n之前的数据包全部确认；SR则收到n的ack包，仅仅确认n。

  - 此外，接收端的重传，开辟一个新的线程进行更好，但新的线程意味着需要引入锁、控制变量；我并没有很好解决l

  

#### 关于连续多届继承下的rooter.exe程序，它的效果实际并不好：

> 对于丢包，若设置10%的丢包率，只会丢失你发送的10个包的第10个；		
>
> 对于延时，对每一个包都延时一个你设置好的那个时间。

这种情况下的模拟，使得传输的数据包都是按序的，实际上是有一些列问题的，例如GBN实验中如果设置丢包率为0，GBN的累计确认是无法发生，那么它和停等机制效果相同...











